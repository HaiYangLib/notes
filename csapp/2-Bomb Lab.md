# 第二个实验 2-Bomb Lab
**phase_1**
答案：
***Border relations with Canada have never been better.***
![第一个炸弹](https://img-blog.csdnimg.cn/20200620182628981.JPG)

**phase_2**
答案：
***1 2 4 8 16 32***

**phase_3**
答案是下面8组数的任意一组：
***0 207
1 311
2 707
3 256
4 389
5 206
6 682
7 327***

**pahase_4**
答案也不唯一，可以是
***7 0***

**phase_5**
答案是六个字母，且这六个字母的ASCII的**后四位**用十进制表示分别为9 15 14 5 6 7 (或者用十六进制为 0x9 0xf 0xe 0x5 0x6 0x7)
答案不唯一可以是：
***ionefg***      (其十六进制为 0x69 0x6f 0x6e 0x65 0x66 0x67)
也可以是：
***yonuvw***     (其十六进制为 0x79 0x6f 0x6e 0x75 0x76 0x77)


**phase_6**
答案是6个不大于6的数字，6个数字全不相等，且会根据每个数字是否为6，采取不同的操作，而且还涉及一个链表。其实有用的信息大部分我都得到了，但是这个炸弹的相关代码太长了，而且跳来跳去，一不留神就要重新推导，草稿纸都不够用了。
前5个炸弹都没有GDB调试，但是最后一个炸弹太难了，所以决定借助GDB调试
```shell
    (gdb) b（breakpoint）: 用法：b 函数名 ：对此函数进行中断 ；b 文件名：行号；
    (gdb) run：启动程序，运行至程序的断点或者结束；
    (gdb) l(list): 用法：l funcname，制定函数的源码
    (gdb) s(step): 进入函数，逐语句运行；
    (gdb) n(next): 不进入函数，逐过程运行；
    (gdb) c（continue）：继续运行，跳至下一个断点；
    (gdb) p（print）：打印显示变量值；
    (gdb) set variable=value, 为变量赋值；
    (gdb) kill：终止调试的程序；
    (gdb) h（help）：列出 gdb 详细命令帮助列表；
    (gdb) clear filename.c:30：清除 30 行处的断点；
    (gdb) info break：显示断点信息；
    (gdb) delete 断点编号：断点编号是 info break 后显示出来的；
    (gdb) bt（backtrace）：回溯到段出错的位置；
    (gdb) frame 帧号：帧号是 bt 命令产生的堆栈针；
    (gdb) q：退出；
    (gdb) x(examine)：查看内存中的值等 // 详细内容在 gdb 中输入 help x 查看
```
用了一整天时间，发现GDB还是用不惯，最后还是得靠自己推，感觉自己像是个**侦探**。
通过分析代码，假设输入的6个数字分别是：**num[0],num[1],num[2],num[3],num[4],num[5]**
分别用0x7减去这些数字得到：**j=7-num[i],  i=0~5**。
表示在第**i+1**个位置上放节点**node j** .

链表含有6个节点（node），每个node都有两个四字节的数字以及一个指针，程序会根据输入的六个数字，对原有的6个节点以节点的第一个数字单调不增的顺序排序（实际就是单调递减）
下面只给出每个节点的数字值(忽略指针值)
**node1：0x00 00 01 4c   0x00 00 00 01
node2：0x00 00 00 a8   0x00 00 00 02
node3：0x00 00 03 9c   0x00 00 00 03
node4：0x00 00 02 b3   0x00 00 00 04
node5：0x00 00 01 dd   0x00 00 00 05
node6：0x00 00 01 bb   0x00 00 00 06**
重新排序的结果应当是 **node3-->node4-->node5-->node6--node1-->node2**
所以7-num[0]=3, 7-num[1]=4, 7-num[2]=5 .....
**phase答案：
4 3 2 1 6 5**
```Assembly
00000000004010f4 <phase_6>:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
调用read_six_numbers 读取6个数字,放在以rsp开始的栈空间;
假设六个数字分别为num[0],num[1]....num[5]
  4010f4:	41 56                	push   %r14
  4010f6:	41 55                	push   %r13
  4010f8:	41 54                	push   %r12
  4010fa:	55                   	push   %rbp
  4010fb:	53                   	push   %rbx           
  4010fc:	48 83 ec 50          	sub    $0x50,%rsp  ;分配栈空间                                         
  401100:	49 89 e5             	mov    %rsp,%r13   ;r13=rsp         
  401103:	48 89 e6             	mov    %rsp,%rsi   ;rsi=rsp
  401106:	e8 51 03 00 00       	callq  40145c <read_six_numbers>  ;读取6个数字,放在以rsp开始的栈空间中,
                                                                          ;假设六个数字分别为num[0],num[1]....num[5]
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
  40110b:	49 89 e6             	mov    %rsp,%r14           ;r14=rsp
  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d          ;r12d=0 

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6个数字均小于或等于6，且6个数字之间或不相等
  401114:	4c 89 ed             	mov    %r13,%rbp	;rsp=r13=rsp
  401117:	41 8b 45 00          	mov    0x0(%r13),%eax	;eax=num[0]
  40111b:	83 e8 01             	sub    $0x1,%eax	;eax=num[0]-1
  40111e:	83 f8 05             	cmp    $0x5,%eax	;num[0]-1必小于或等于0x5,即num[0]不大于6
  401121:	76 05                	jbe    401128 <phase_6+0x34>	;跳到401128
  401123:	e8 12 03 00 00       	callq  40143a <explode_bomb>	
  401128:	41 83 c4 01          	add    $0x1,%r12d	;r12d=r12d+1=1
  40112c:	41 83 fc 06          	cmp    $0x6,%r12d
  401130:	74 21                	je     401153 <phase_6+0x5f>i	;跳出大循环
  401132:	44 89 e3             	mov    %r12d,%ebx
***********************************************************
  401135:	48 63 c3             	movslq %ebx,%rax
  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax
  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)
  40113e:	75 05                	jne    401145 <phase_6+0x51>
  401140:	e8 f5 02 00 00       	callq  40143a <explode_bomb>
  401145:	83 c3 01             	add    $0x1,%ebx
  401148:	83 fb 05             	cmp    $0x5,%ebx
  40114b:	7e e8                	jle    401135 <phase_6+0x41>
***********************************************************
  40114d:	49 83 c5 04          	add    $0x4,%r13
  401151:	eb c1                	jmp    401114 <phase_6+0x20>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi	;rsi=rsp+0x18  
  401158:	4c 89 f0             	mov    %r14,%rax
  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx

////////////////////////////////////////////////////////////////////////////////
用7-num[x]代替原来的num[x]
  401160:	89 ca                	mov    %ecx,%edx        ;ecx=7
  401162:	2b 10                	sub    (%rax),%edx	;edx=7-num[x]
  401164:	89 10                	mov    %edx,(%rax)	;num[x]=7-num[x]	
  401166:	48 83 c0 04          	add    $0x4,%rax        ;rax=&num[x+1]
  40116a:	48 39 f0             	cmp    %rsi,%rax	;rsi=rsp+0x18
  40116d:	75 f1                	jne    401160 <phase_6+0x6c>
////////////////////////////////////////////////////////////////////////////////

  40116f:	be 00 00 00 00       	mov    $0x0,%esi	;esi=0
  401174:	eb 21                	jmp    401197 <phase_6+0xa3>

*******************************************************************************
根据输入数字对将链表分配到栈的不同位置
  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx	;rdx=rdx+0x8
  40117a:	83 c0 01             	add    $0x1,%eax        ;eax=eax+1
  40117d:	39 c8                	cmp    %ecx,%eax	;ecx=7-num[x] 且7-num[x]>1 
  40117f:	75 f5                	jne    401176 <phase_6+0x82>	
  401181:	eb 05                	jmp    401188 <phase_6+0x94>	;eax一直累加到7-num[x]时，跳转
*****************************************************rsi=0
  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx
  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)	;将节点保存在栈中
  40118d:	48 83 c6 04          	add    $0x4,%rsi	;rsi=rsi+4
  401191:	48 83 fe 18          	cmp    $0x18,%rsi
  401195:	74 14                	je     4011ab <phase_6+0xb7>
  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx	;ecx=(rsp+rsi)
  40119a:	83 f9 01             	cmp    $0x1,%ecx	;比较7-num[x]是否小于等于1，由于num[x]<=6，若7-num[x]<=1,则num[x]=6
  40119d:	7e e4                	jle    401183 <phase_6+0x8f>	;若num[x]==6,则跳转
*****************************************************
  40119f:	b8 01 00 00 00       	mov    $0x1,%eax	;eax=1
  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx
  4011a9:	eb cb                	jmp    401176 <phase_6+0x82>
*******************************************************************************
  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi
  4011ba:	48 89 d9             	mov    %rbx,%rcx

-------------------------------------------------------------------------------
调整链表指针
  4011bd:	48 8b 10             	mov    (%rax),%rdx
  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  4011c4:	48 83 c0 08          	add    $0x8,%rax
  4011c8:	48 39 f0             	cmp    %rsi,%rax
  4011cb:	74 05                	je     4011d2 <phase_6+0xde>
  4011cd:	48 89 d1             	mov    %rdx,%rcx
  4011d0:	eb eb                	jmp    4011bd <phase_6+0xc9>
  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)	；最后一个节点的尾指针等于0
-------------------------------------------------------------------------------

  4011d9:	00 
  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
检查节点数值是否单调不增
  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax
  4011e3:	8b 00                	mov    (%rax),%eax	;这行代码可以推定，比较的数值是四个字节
  4011e5:	39 03                	cmp    %eax,(%rbx) 	;也可以推出，node节点含有两个四字节的数值，以及一个指针
  4011e7:	7d 05                	jge    4011ee <phase_6+0xfa>
  4011e9:	e8 4c 02 00 00       	callq  40143a <explode_bomb>
  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx
  4011f2:	83 ed 01             	sub    $0x1,%ebp
  4011f5:	75 e8                	jne    4011df <phase_6+0xeb>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  4011f7:	48 83 c4 50          	add    $0x50,%rsp
  4011fb:	5b                   	pop    %rbx
  4011fc:	5d                   	pop    %rbp
  4011fd:	41 5c                	pop    %r12
  4011ff:	41 5d                	pop    %r13
  401201:	41 5e                	pop    %r14
  401203:	c3                   	retq   


///////////////////////////////////////////////////////////////////////////////////
链表，一共6个节点
00000000006032d0 <node1>:   ;原数据采用小端表示 实际node1中数据值为00 00 00 01 00 00 01 4c  
  6032d0:	4c 01 00             	add    %r8,(%rax)
  6032d3:	00 01                	add    %al,(%rcx)
  6032d5:	00 00                	add    %al,(%rax)
  6032d7:	00 e0                	add    %ah,%al
  6032d9:	32 60 00             	xor    0x0(%rax),%ah
  6032dc:	00 00                	add    %al,(%rax)
	...

00000000006032e0 <node2>: ;node2 00 00 00 02 00 00 00 a8
  6032e0:	a8 00                	test   $0x0,%al
  6032e2:	00 00                	add    %al,(%rax)
  6032e4:	02 00                	add    (%rax),%al
  6032e6:	00 00                	add    %al,(%rax)
  6032e8:	f0 32 60 00          	lock xor 0x0(%rax),%ah
  6032ec:	00 00                	add    %al,(%rax)
	...

00000000006032f0 <node3>: ;node3 00 00 00 03 00 00 03 9c
  6032f0:	9c                   	pushfq 
  6032f1:	03 00                	add    (%rax),%eax
  6032f3:	00 03                	add    %al,(%rbx)
  6032f5:	00 00                	add    %al,(%rax)
  6032f7:	00 00                	add    %al,(%rax)
  6032f9:	33 60 00             	xor    0x0(%rax),%esp
  6032fc:	00 00                	add    %al,(%rax)
	...

0000000000603300 <node4>: ;node4 00 00 00 04 00 00 02 b3
  603300:	b3 02                	mov    $0x2,%bl
  603302:	00 00                	add    %al,(%rax)
  603304:	04 00                	add    $0x0,%al
  603306:	00 00                	add    %al,(%rax)
  603308:	10 33                	adc    %dh,(%rbx)
  60330a:	60                   	(bad)  
  60330b:	00 00                	add    %al,(%rax)
  60330d:	00 00                	add    %al,(%rax)
	...

0000000000603310 <node5>:  ;00 00 00 05 00 00 01 dd
  603310:	dd 01                	fldl   (%rcx)
  603312:	00 00                	add    %al,(%rax)
  603314:	05 00 00 00 20       	add    $0x20000000,%eax
  603319:	33 60 00             	xor    0x0(%rax),%esp
  60331c:	00 00                	add    %al,(%rax)
	...

0000000000603320 <node6>:  ;00 00 00 06 00 00 01 bb
  603320:	bb 01 00 00 06       	mov    $0x6000001,%ebx
	...

///////////////////////////////////////////////////////////////////////////////////


```